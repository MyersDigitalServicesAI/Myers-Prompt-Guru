/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user data, including profiles and prompts, is private and accessible only by the authenticated user who owns it. This ensures user data privacy and isolation.
 *
 * Data Structure: Data is hierarchically organized under a top-level `users` collection. Each user's data is stored in their own document tree, for example: `/users/{userId}` for their profile and `/users/{userId}/prompts/{promptId}` for their prompts. This path-based ownership is the cornerstone of the security model.
 *
 * Key Security Decisions:
 * - User Enumeration is Forbidden: Listing the top-level `/users` collection is explicitly denied to prevent malicious actors from discovering all users of the application.
 * - Strict Path-Based Ownership: All access decisions for subcollections (like `/prompts`) are based on the `{userId}` wildcard in the path, ensuring a user can only ever access data within their own tree.
 * - Default Deny: Any path not explicitly matched is inaccessible. All operations (`get`, `list`, `create`, `update`, `delete`) are denied by default unless an `allow` rule specifically grants access.
 * - Stripe Field Protection: Stripe-related fields (stripeCustomerId, stripeSubscriptionId, subscriptionStatus, isPro) cannot be modified by clients. Only backend services can update these fields.
 *
 * Denormalization for Authorization: This ruleset leverages a path-based security model which is highly performant. The user's ID (`userId`) in the document path (`/users/{userId}/...`) is the source of truth for ownership, eliminating the need for slow and costly `get()` calls to other documents for authorization checks.
 *
 * Structural Segregation: User-specific, private data (like `prompts`) is nested within that user's document path. This is a secure pattern that prevents data leakage and simplifies rules for list operations, as a user is only ever allowed to list documents within their own subcollections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if a user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the currently authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing data ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Checks for ownership on an existing document. Used for update and delete
     * operations to ensure the document exists before the operation is attempted.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the incoming 'User' document contains an 'id' field
     * that matches the user's auth UID, enforcing relational integrity on creation.
     */
    function isCreatingValidUser(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Validates that the 'id' field of a 'User' document is immutable.
     * This prevents an ownership link from being changed after creation.
     * 
     * STRIPE SECURITY: Also prevents clients from modifying Stripe-related fields.
     * Only backend services (via Admin SDK) can update these fields.
     */
    function isUpdatingValidUser() {
      let validIdUpdate = request.resource.data.id == resource.data.id;
      
      // List of Stripe fields that cannot be modified by clients
      let stripeFields = ['stripeCustomerId', 'stripeSubscriptionId', 'subscriptionStatus', 
                          'subscriptionEndDate', 'cancelAtPeriodEnd'];
      
      // Check if any Stripe field is being modified
      let stripeFieldsUnchanged = !request.resource.data.keys().hasAny(stripeFields) ||
        ((!('stripeCustomerId' in request.resource.data) || 
          request.resource.data.stripeCustomerId == resource.data.get('stripeCustomerId', null)) &&
         (!('stripeSubscriptionId' in request.resource.data) || 
          request.resource.data.stripeSubscriptionId == resource.data.get('stripeSubscriptionId', null)) &&
         (!('subscriptionStatus' in request.resource.data) || 
          request.resource.data.subscriptionStatus == resource.data.get('subscriptionStatus', null)) &&
         (!('subscriptionEndDate' in request.resource.data) || 
          request.resource.data.subscriptionEndDate == resource.data.get('subscriptionEndDate', null)) &&
         (!('cancelAtPeriodEnd' in request.resource.data) || 
          request.resource.data.cancelAtPeriodEnd == resource.data.get('cancelAtPeriodEnd', null)));
      
      // isPro field also cannot be modified by clients (only backend via webhooks)
      let isProUnchanged = !('isPro' in request.resource.data) || 
                           request.resource.data.isPro == resource.data.get('isPro', false);
      
      return validIdUpdate && stripeFieldsUnchanged && isProUnchanged;
    }

    /**
     * Validates that the incoming 'Prompt' document contains a 'userId' field
     * that matches the owner's auth UID from the path.
     */
    function isCreatingValidPrompt(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Validates that the 'userId' field of a 'Prompt' document is immutable.
     */
    function isUpdatingValidPrompt() {
      return request.resource.data.userId == resource.data.userId;
    }

    // ------------------------------------------------------------------------
    // Collection Rules
    // ------------------------------------------------------------------------

    /**
     * @description Manages user profile documents.
     * @path /users/{userId}
     * @allow A user (auth.uid='user123') can (get) their own profile at /users/user123.
     * @deny A user (auth.uid='userABC') cannot (get) another user's profile at /users/user123.
     * @deny A user cannot modify Stripe-related fields or isPro status (backend-only).
     * @principle Restricts access to a user's own data tree and prevents user enumeration.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && isCreatingValidUser(userId);
      allow update: if isExistingOwner(userId) && isUpdatingValidUser();
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Manages user-created prompts, nested under the user's profile.
     * @path /users/{userId}/prompts/{promptId}
     * @allow A user (auth.uid='user123') can (create) a new prompt at /users/user123/prompts/promptABC.
     * @deny A user (auth.uid='userABC') cannot (list) prompts from /users/user123/prompts.
     * @principle Enforces document ownership for all operations via path-based security.
     */
    match /users/{userId}/prompts/{promptId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && isCreatingValidPrompt(userId);
      allow update: if isExistingOwner(userId) && isUpdatingValidPrompt();
      allow delete: if isExistingOwner(userId);

      /**
       * @description Manages historical versions of a prompt.
       * @path /users/{userId}/prompts/{promptId}/versions/{versionId}
       * @allow An owner can create and view history.
       * @deny History is immutable; no updates or deletes are allowed.
       * @principle Preserves the integrity of a prompt's history.
       */
      match /versions/{versionId} {
        allow get: if isOwner(userId);
        allow list: if isOwner(userId);
        allow create: if isOwner(userId);
        allow update: if false;
        allow delete: if false;
      }
    }
    
    /**
     * @description Manages analytics events for a user's prompts.
     * @path /users/{userId}/promptEvents/{eventId}
     * @allow A user can create and read their own events.
     * @deny Reading or writing events for another user is forbidden.
     * @principle Write-only log for analytics, readable only by the owner.
     */
    match /users/{userId}/promptEvents/{eventId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if false;
      allow delete: if false;
    }
  }
}
